/*
 * Copyright 2022 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include "fsl_device_registers.h"
#include "fsl_debug_console.h"
#include "pin_mux.h"
#include "clock_config.h"
#include "board.h"
#include "fsl_romapi_nboot.h"

#include <string.h>

#include "fsl_power.h"
/*******************************************************************************
 * Definitions
 ******************************************************************************/

#define MEM_PATTERN (0xA5)

/*
 * @brief Helper to assert function return status.
 *
 * @details Print finshed message and trap forever upon failure.
 */
#define APP_ASSERT(expected, actual, ...) \
    do                                    \
    {                                     \
        if (expected != actual)           \
        {                                 \
            PRINTF("Example failed: ");   \
            PRINTF(__VA_ARGS__);          \
            while (1)                     \
                ;                         \
        }                                 \
    } while (0);

/*******************************************************************************
 * Prototypes
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/


/*******************************************************************************
 * Code
 ******************************************************************************/
void test_romapi_rng_generate_random()
{
    PRINTF("INFO: Starting Example %s \r\n", __func__);
    uint32_t data_buf[4]        = {0};
    nboot_status_t nboot_status = romapi_rng_generate_random((uint8_t *)&data_buf[0], sizeof(data_buf));
    APP_ASSERT(kStatus_NBOOT_Success, nboot_status, "romapi_rng_generate_random returned with code [0x%X]\r\n",
               nboot_status);

    for (int i = 0; i < sizeof(data_buf) / sizeof(uint32_t); i++)
    {
        PRINTF("data_buf[%d] = 0x%X\r\n", i, data_buf[i]);
    }

    PRINTF("INFO: Finished Example %s \r\n", __func__);
}

void test_nboot_context_init(void)
{
    PRINTF("INFO: Starting Example %s \r\n", __func__);
    // At the beggining initialise the nboot context with some not trivial MEMORY_PATTERN, which should change after
    // returning from the Function Under Test --
    nboot_context_t dummy_nboot_ctx;
    (void)memset(&dummy_nboot_ctx, MEM_PATTERN, sizeof(dummy_nboot_ctx));

    nboot_context_t test_nboot_ctx;
    (void)memset(&test_nboot_ctx, MEM_PATTERN, sizeof(test_nboot_ctx));
    nboot_status_t nboot_status = nboot_context_init(&test_nboot_ctx);
    if (0 == memcmp(&dummy_nboot_ctx, &test_nboot_ctx, sizeof(dummy_nboot_ctx)))
    {
        nboot_status = kStatus_NBOOT_Fail;
    }
    APP_ASSERT(kStatus_NBOOT_Success, nboot_status, "nboot_context_init returned with code [0x%X]\r\n", nboot_status);

    PRINTF("INFO: Finished Example %s \r\n", __func__);
}

void test_nboot_context_deinit(void)
{
    PRINTF("INFO: Starting Example %s \r\n", __func__);
    nboot_context_t dummy_nboot_ctx;
    (void)memset(&dummy_nboot_ctx, MEM_PATTERN, sizeof(dummy_nboot_ctx));

    // At the beggining initialise the nboot context with some not trivial MEMORY_PATTERN, which should change after
    // returning from the Function Under Test --
    nboot_context_t test_nboot_ctx;
    (void)memcpy(&test_nboot_ctx, &dummy_nboot_ctx, sizeof(dummy_nboot_ctx));
    nboot_status_t nboot_status = nboot_context_deinit(&test_nboot_ctx);

    if (0 == memcmp(&dummy_nboot_ctx, &test_nboot_ctx, sizeof(dummy_nboot_ctx)))
    {
        nboot_status = kStatus_NBOOT_Fail;
    }
    APP_ASSERT(kStatus_NBOOT_Success, nboot_status, "nboot_context_deinit returned with code [0x%X]\r\n", nboot_status);

    PRINTF("INFO: Finished Example %s \r\n", __func__);
}

#ifdef ENABLE_NBOOT_LOAD_BLOCK_OPERATIONS
// CTRK HASH of the SimpleOS RAM application --
static uint8_t const test_rkh_256_valid[] = {
    0x3fu, 0x1fu, 0x71u, 0xccu, 0xd8u, 0xdfu, 0xcbu, 0xcfu, 0xf3u, 0xe4u, 0x45u, 0xc2u, 0x1fu, 0x00u, 0x3au, 0x97u,
    0x4fu, 0x8cu, 0x40u, 0xceu, 0x9au, 0xa7u, 0xd8u, 0xc5u, 0x67u, 0x41u, 0x6bu, 0x9au, 0xb4u, 0x5du, 0x16u, 0x55u};

// Content of the SimpleOS RAM sb3 file --
// NOTE: Needs to be word aligned.
__ALIGNED(sizeof(uint32_t))
static uint8_t const test_sb3_file_valid[] = {
    0x73, 0x62, 0x76, 0x33,                         // magic
    0x01, 0x00, 0x03, 0x00,                         // formatVersion
    0x00, 0x00, 0x00, 0x00,                         // flags
    0x02, 0x00, 0x00, 0x00,                         // blockCount
    0x24, 0x01, 0x00, 0x00,                         // blockSize
    0x87, 0xBB, 0x2F, 0x29, 0x00, 0x00, 0x00, 0x00, // timeStamp
    0x01, 0x00, 0x00, 0x00,                         // firmwareVersion
    0x6C, 0x01, 0x00, 0x00,                         // imageTotalLength
    0x06, 0x00, 0x00, 0x00,                         // imageType
    0x5C, 0x00, 0x00, 0x00,                         // certificateBlockOffset
    0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6F, 0x73, // description[0-7]
    0x5F, 0x72, 0x61, 0x6D, 0x5F, 0x73, 0x62, 0x33, // description[8-15]
                                                    // SHA-256 of block1 starts here
    0xB4, 0x14, 0x65, 0x96, 0x77, 0xD1, 0x23, 0x44, 0x7E, 0x8C, 0x4E, 0x8A, 0xC1, 0x01, 0x3F, 0x93, 0x9F, 0x26, 0x53,
    0x14, 0x82, 0xA6, 0x49, 0x03, 0xB8, 0x4F, 0xAA, 0x9E, 0x71, 0xF1, 0x23, 0x84,
    // certBlk starts here
    0x63, 0x68, 0x64, 0x72, // magic
    0x01, 0x00, 0x02, 0x00, // formatMajorMinorVersion
    0xD0, 0x00, 0x00, 0x00, // certBlockSize
    0x41, 0x00, 0x00, 0x80, // flags

    0x67, 0x1E, 0x3F, 0x71, 0x08, 0x62, 0x18, 0x30, 0xC0, 0x8D, 0xF0, 0x3C, 0x33, 0x9D, 0x2C, 0xE9, 0x70, 0x0C, 0x0A,
    0x4B, 0xD7, 0x4F, 0x7B, 0xFB, 0xCC, 0x48, 0xFB, 0xE2, 0x7C, 0x78, 0xBF, 0x05, 0x77, 0x06, 0x58, 0x72, 0x72, 0x4C,
    0x0D, 0x57, 0x56, 0x26, 0xD4, 0x43, 0x05, 0x49, 0x8A, 0xA3, 0xB1, 0xD6, 0x56, 0xE1, 0xDC, 0x3F, 0xCA, 0x4D, 0xE8,
    0xC7, 0x1A, 0x5E, 0x68, 0xAF, 0x26, 0x8B, 0x46, 0x44, 0x15, 0xEE, 0xDA, 0xF9, 0x92, 0x20, 0xCA, 0x81, 0x04, 0x0C,
    0x07, 0xAB, 0xDA, 0x5C, 0x91, 0x9E, 0x0E, 0x32, 0x53, 0xC0, 0x47, 0x23, 0x70, 0x08, 0x50, 0x82, 0x65, 0x21, 0xD0,
    0xEB, 0x90, 0x04, 0x2D, 0x18, 0xF6, 0xB1, 0x0F, 0x81, 0x79, 0x83, 0xD9, 0x84, 0x17, 0x1A, 0xA7, 0x4A, 0xF2, 0x5B,
    0x72, 0x24, 0x50, 0x5E, 0xE6, 0xEE, 0xA5, 0x66, 0x3A, 0xD7, 0x50, 0x02, 0xD6, 0x65, 0xE1, 0xCC, 0xF1, 0x62, 0xD1,
    0xBB, 0xD4, 0x91, 0x75, 0xED, 0xFF, 0x19, 0xC5, 0xD1, 0x26, 0x4A, 0x21, 0x64, 0x8E, 0x86, 0x29, 0x8F, 0x0F, 0x66,
    0x69, 0x58, 0xE1, 0x25, 0x9B, 0x04, 0x81, 0x57, 0x96, 0x2C, 0x70, 0x61, 0x7B, 0xAA, 0x5F, 0xB4, 0x0E, 0x13, 0xE9,
    0xF9, 0xEF, 0xE9, 0x04, 0xCD, 0x57, 0x08, 0x65, 0xEA, 0x7F, 0xA5, 0xD9, 0x2C, 0xF1, 0xF2, 0x8E, 0x26, 0xF6, 0x9E,
    0x9A, 0x44, 0x97, 0x55, 0xE5, 0xA2, 0x67, 0xE3, 0x3B, 0x4A, 0x87, 0x40, 0x72, 0xEB, 0xF9, 0xCD, 0xC5, 0x01, 0x93,
    0x71, 0x7E, 0x5A, 0x15, 0x3B, 0xBA, 0xB6, 0x31, 0xDC, 0x8E, 0x69, 0xB9, 0xBA, 0x95, 0x5D, 0x81, 0x1F, 0x03, 0x5D,
    0x60, 0x3E, 0x60, 0x58, 0x3E, 0x09, 0x17, 0x60, 0xBB, 0x78, 0x92, 0xE2, 0xEB, 0x2F, 0x14, 0x10, 0x99, 0xBA, 0xF4,
    0x31, 0x44, 0x11, 0x2B, 0x5A, 0xCE, 0xE4, 0xD8, 0xA7,

    0x01, 0x00, 0x00, 0x00, // blockNumber
                            // SHA-256 of block2 starts here
    0x81, 0xA2, 0x3C, 0x6A, 0xB7, 0x09, 0xDD, 0x76, 0xE9, 0x5E, 0x60, 0xB8, 0xA3, 0xA4, 0x91, 0xEE, 0xE4, 0xF6, 0xAA,
    0x42, 0x4B, 0x13, 0xE7, 0x8E, 0x55, 0x96, 0x71, 0x83, 0x44, 0xBE, 0xAC, 0xA0,
    // block1 data chunk starts here
    0x71, 0x68, 0x7D, 0xA5, 0x07, 0xD5, 0xE4, 0xE3, 0x9B, 0xDD, 0x35, 0x1E, 0x35, 0xCE, 0xFF, 0xC6, 0x83, 0x83, 0xD5,
    0xB8, 0x54, 0xAD, 0x04, 0x1E, 0x22, 0x34, 0xBB, 0x03, 0xF1, 0x50, 0x57, 0x56, 0x7A, 0x41, 0x46, 0xD5, 0x45, 0x9A,
    0x2F, 0xA5, 0x83, 0x67, 0x68, 0x91, 0xB5, 0x2A, 0x98, 0x9B, 0x94, 0xE1, 0xF0, 0x73, 0x3F, 0x9C, 0x94, 0xFF, 0x71,
    0x14, 0x17, 0xC6, 0x11, 0x15, 0x42, 0x3C, 0x59, 0xF8, 0x1C, 0xA0, 0xE1, 0xCE, 0x26, 0x80, 0x7C, 0x24, 0x1F, 0xD8,
    0x93, 0x28, 0x33, 0x9A, 0x1D, 0xE0, 0xB3, 0xA2, 0xCD, 0x23, 0xE0, 0x4C, 0x68, 0x85, 0x03, 0x2E, 0xE4, 0xCB, 0x1E,
    0x3F, 0xBB, 0x2D, 0x95, 0xEC, 0x65, 0xF8, 0xB4, 0x40, 0x6F, 0x88, 0xD2, 0x1C, 0xDC, 0xF0, 0x9B, 0x95, 0x86, 0x0C,
    0xB0, 0x9E, 0xA3, 0xF5, 0x4C, 0xB3, 0x53, 0xBC, 0x98, 0xBA, 0x2A, 0xE8, 0x6F, 0x28, 0x2B, 0x34, 0x08, 0x28, 0x19,
    0x7B, 0xBF, 0xBE, 0x71, 0x4D, 0x07, 0xB2, 0xB0, 0xFC, 0xCC, 0xC7, 0x85, 0x05, 0xE3, 0x57, 0xD4, 0x84, 0x85, 0x63,
    0x87, 0x6E, 0xA6, 0x7B, 0x5A, 0x02, 0x03, 0xA6, 0x82, 0x9C, 0x5F, 0xEB, 0x17, 0xD7, 0x22, 0x0A, 0x54, 0x43, 0xF1,
    0x3E, 0xBE, 0x3A, 0x75, 0x1B, 0x4B, 0xF9, 0x69, 0x43, 0xC9, 0x6C, 0x11, 0xE8, 0xBC, 0xD0, 0x8C, 0x5E, 0xC0, 0x12,
    0xC0, 0x99, 0xB6, 0x2A, 0x2D, 0x2B, 0xE3, 0xCA, 0xBE, 0x72, 0x20, 0x58, 0x6F, 0xB0, 0x30, 0xF6, 0x56, 0x15, 0x81,
    0x75, 0x27, 0xFD, 0x79, 0x52, 0xC5, 0xA4, 0x83, 0x8D, 0x9B, 0x06, 0xCD, 0x75, 0xAC, 0x2B, 0x2D, 0x18, 0x43, 0x0D,
    0x84, 0xC2, 0x81, 0xD6, 0x73, 0xA1, 0x93, 0x9C, 0xA0, 0x45, 0x22, 0xDD, 0x00, 0x78, 0x82, 0xC0, 0x7F, 0x48, 0xB1,
    0xE1, 0x31, 0x99, 0xC6, 0x43, 0x0F, 0x04, 0x84, 0x7B,

    0x02, 0x00, 0x00, 0x00, // blockNumber
                            // SHA-256 of block2 starts here
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // block2 data chunk starts here
    0xA1, 0x6A, 0x7C, 0x21, 0xD5, 0xC2, 0x04, 0xEF, 0x29, 0x2C, 0x96, 0x85, 0x37, 0xBE, 0x6F, 0xCE, 0x06, 0xC7, 0x4E,
    0xE7, 0x0C, 0x92, 0xBC, 0x10, 0x13, 0x3F, 0x38, 0xB5, 0xC9, 0x69, 0xF5, 0xE2, 0xFA, 0x72, 0x12, 0x68, 0xED, 0xA5,
    0x91, 0xF4, 0x36, 0x5C, 0x92, 0xB8, 0xE3, 0x34, 0x9B, 0xD8, 0xD7, 0x92, 0x96, 0xEE, 0x20, 0xED, 0x8E, 0xCB, 0x6C,
    0xFD, 0xE2, 0x20, 0xB7, 0x97, 0xCC, 0x32, 0x5E, 0xB6, 0x74, 0x9E, 0x2A, 0xDA, 0x7F, 0xC5, 0x86, 0x94, 0x4A, 0xCB,
    0x5A, 0x4C, 0xC9, 0xE1, 0xFF, 0xE0, 0x93, 0x38, 0x3D, 0xDA, 0xA1, 0xB7, 0x13, 0xEB, 0x8F, 0x8A, 0x6C, 0x95, 0xA6,
    0x29, 0x4A, 0xD8, 0x54, 0x97, 0x70, 0xAA, 0x8E, 0x4F, 0x99, 0x3A, 0x77, 0xFE, 0x47, 0x14, 0x65, 0xCD, 0x0F, 0x77,
    0xD6, 0x21, 0x72, 0x59, 0xD1, 0x6C, 0x38, 0xB1, 0x47, 0xC1, 0xC6, 0x3C, 0xFC, 0xC9, 0x8C, 0xAC, 0x3E, 0x9A, 0x58,
    0x41, 0x0A, 0x1B, 0xB2, 0x7F, 0x81, 0xC8, 0xBE, 0xDD, 0x0B, 0xF4, 0xAB, 0xDD, 0x3D, 0x4F, 0xB0, 0x7C, 0x57, 0x22,
    0x5B, 0x3A, 0x76, 0xCE, 0x66, 0x23, 0x2D, 0xF4, 0x7B, 0x8F, 0xC2, 0xEA, 0xB1, 0xC4, 0xD7, 0xC8, 0x15, 0x4C, 0x34,
    0x9C, 0x44, 0x62, 0xD3, 0xE9, 0xFC, 0x29, 0x17, 0xCE, 0x41, 0x94, 0xD1, 0x09, 0xD6, 0x76, 0xFF, 0xE4, 0xBA, 0xE6,
    0xDB, 0xB1, 0xFC, 0xAA, 0xF2, 0xB0, 0xE4, 0x8B, 0xB4, 0x6B, 0xFF, 0xE3, 0x12, 0xAF, 0x12, 0xEA, 0x1A, 0x35, 0x33,
    0x87, 0x9A, 0x7E, 0x57, 0x23, 0x1B, 0x7E, 0xAA, 0x0C, 0xBE, 0x3C, 0x8F, 0x4E, 0x57, 0x0D, 0x39, 0x7E, 0xA5, 0x41,
    0xC2, 0xEE, 0x35, 0x97, 0x86, 0x0C, 0xEA, 0xD7, 0xD8, 0xF4, 0xFB, 0xD4, 0xF4, 0x02, 0xCD, 0xF4, 0xC9, 0x8A, 0xC4,
    0xED, 0x58, 0x54, 0x55, 0x4A, 0xA7, 0x1C, 0xDB, 0x67};

static uint32_t *const test_manifest_valid_ptr = (uint32_t *)test_sb3_file_valid;

// OTP Fusemap records 92 to 103 taken from otp_fusemap_256.xml --
// NOTE: Endianness change applied.
static uint8_t const test_pck_blob_valid[] = {0x65, 0xDE, 0x69, 0xAE, 0x7D, 0x6A, 0xC5, 0xBB, 0xA2, 0x21, 0x80, 0x72,
                                              0x52, 0xA1, 0xF3, 0xBC, 0xD9, 0x82, 0x04, 0xAD, 0xC8, 0x86, 0x74, 0xC7,
                                              0xB3, 0x07, 0xEC, 0xC9, 0x49, 0x41, 0x55, 0x52, 0x29, 0x9A, 0xEE, 0x01,
                                              0xCF, 0x14, 0xB3, 0x60, 0x61, 0x44, 0x7B, 0x00, 0x6E, 0xE8, 0x2B, 0x4C};
static void set_valid_manifest_params(nboot_sb3_load_manifest_parms_t *const params)
{
    uint32_t const no_of_root_keys = ARRAY_SIZE(params->soc_RoTNVM.soc_rootKeyRevocation);

    (void)memset(params, 0, sizeof(*params));

    for (uint8_t i = 0; i < no_of_root_keys; i++)
    {
        params->soc_RoTNVM.soc_rootKeyRevocation[i] = kNBOOT_RootKey_Enabled;
        params->soc_RoTNVM.soc_rootKeyUsage[i]      = kNBOOT_RootKeyUsage_DebugCA_ImageCA_FwCA_ImageKey_FwKey;
    }
    params->soc_RoTNVM.soc_imageKeyRevocation = 0x00;
    (void)memcpy(params->soc_RoTNVM.soc_rkh, test_rkh_256_valid, sizeof(test_rkh_256_valid));
    params->soc_RoTNVM.soc_numberOfRootKeys     = no_of_root_keys;
    params->soc_RoTNVM.soc_rootKeyTypeAndLength = kNBOOT_RootKey_Ecdsa_P256;
    params->soc_RoTNVM.soc_lifecycle            = nboot_lc_nxpBlank;
    params->soc_trustedFirmwareVersion          = 0x00;

    (void)memcpy(params->pckBlob, test_pck_blob_valid, sizeof(test_pck_blob_valid));
}
#endif

void test_nboot_sb3_load_manisfest_and_block(void)
{
#ifdef ENABLE_NBOOT_LOAD_BLOCK_OPERATIONS
#define TEST_SB3_MANIFEST_SIZE_IN_WORDS (91)
    PRINTF("INFO: Starting Example %s \r\n", __func__);

    // size_t sb3_block_size_in_words = test_manifest_valid_ptr[4] / sizeof(uint32_t);
    // uint32_t test_block[sb3_block_size_in_words];
    uint32_t test_block[73];

    nboot_context_t test_nboot_ctx;
    nboot_status_t nboot_status = nboot_context_init(&test_nboot_ctx);
    APP_ASSERT(kStatus_NBOOT_Success, nboot_status, "nboot_context_init returned with code [0x%X]\r\n", nboot_status);

    nboot_sb3_load_manifest_parms_t test_params_valid;
    set_valid_manifest_params(&test_params_valid);

    nboot_status_protected_t nboot_status_protected =
        nboot_sb3_load_manifest(&test_nboot_ctx, test_manifest_valid_ptr, &test_params_valid);

    APP_ASSERT(kStatus_NBOOT_Success, (nboot_status_t)nboot_status_protected,
               "nboot_sb3_load_manifest returned with code [0x%X]\r\n", (nboot_status_t)nboot_status_protected);

    uint32_t *block_valid_ptr = (uint32_t *)test_manifest_valid_ptr + TEST_SB3_MANIFEST_SIZE_IN_WORDS;
    (void)memcpy(test_block, block_valid_ptr, sizeof(test_block));
    nboot_status_protected = nboot_sb3_load_block(&test_nboot_ctx, test_block);
    APP_ASSERT(kStatus_NBOOT_Success, (nboot_status_t)nboot_status_protected,
               "nboot_sb3_load_block returned with code [0x%X]\r\n", (nboot_status_t)nboot_status_protected);
    PRINTF("INFO: Finished Example %s \r\n", __func__);
#endif
}

int main()
{
    /* Init hardware */
    BOARD_InitBootPins();

    if (BOARD_IS_XIP())
    {
        BOARD_BootClockLPR();
        CLOCK_EnableClock(kCLOCK_Otp);
        CLOCK_EnableClock(kCLOCK_Els);
        CLOCK_EnableClock(kCLOCK_ElsApb);
        RESET_PeripheralReset(kOTP_RST_SHIFT_RSTn);
        RESET_PeripheralReset(kELS_APB_RST_SHIFT_RSTn);
    }
    else
    {
        BOARD_InitBootClocks();
        CLOCK_EnableClock(kCLOCK_Flexspi);
        RESET_ClearPeripheralReset(kFLEXSPI_RST_SHIFT_RSTn);
        /* Use aux0_pll_clk / 2 */
        BOARD_SetFlexspiClock(FLEXSPI, 2U, 2U);
    }
    BOARD_InitDebugConsole();
    PRINTF("\r\nROM API NBOOT Driver\r\n");

    test_nboot_context_init();
    test_romapi_rng_generate_random();
    test_nboot_context_deinit();
    test_nboot_sb3_load_manisfest_and_block();

    PRINTF("ALL nboot examples completed successfully!\r\n");
    /* End of example */
    while (1)
    {
    }
}
